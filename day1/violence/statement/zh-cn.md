{{ self.title() }}

{{ s('background') }}

{{ img('background.png', size = 0.21, align = 'middle', inline = False, caption='“猜你会揪着老苏那件事讲半个 minit”') }}

“我们可一直走在一条路上。”

{{ s('description') }}

令我们永远无法释怀的是那场雨。

城市第 $i$ 天的降水量可以用一个整数 $x_i$ 表示。现在 Left 观测了 $n$ 天的降水，猜测了一个序列 $\{a_n\}$。我们认为，若这 $n$ 天每天的降水量都满足 $1\le x_i\le a_i$，那么这 $n$ 天的降水量是**符合 Left 预期的**。

Left 喜欢不单调的雨天。所以若在这 $n$ 天中不存在任意一天的降水量和前一天或后一天相等，那么这 $n$ 天的降水量是**复杂的**。特别地，对于第一天不考虑前一天，对于第 $n$ 天不考虑后一天。

现在给出 $n$ 和 $\{a_n\}$，求出有多少个长度为 $n$ 的不同的**符合 Left 预期的复杂的**实际降水量序列 $\{x_n\}$，对 $10^9+7$ 取模。两个实际降水量序列 $\{x_n\},\{x'_n\}$ 不同当且仅当 $\exists i\in[1,n],x_i\ne x'_i$。

{{ s('input format') }}

{{ self.input_file() }}

为了减少输入量，我们采用如下生成器在你的代码中生成输入数据。

```cpp
int a[/*数组大小*/];
namespace Gen
{
    unsigned z1, z2, z3, z4, b;
    unsigned rand_()
    {
        b = ((z1 << 6) ^ z1) >> 13;
        z1 = ((z1 & 4294967294U) << 18) ^ b;
        b = ((z2 << 2) ^ z2) >> 27;
        z2 = ((z2 & 4294967288U) << 2) ^ b;
        b = ((z3 << 13) ^ z3) >> 21;
        z3 = ((z3 & 4294967280U) << 7) ^ b;
        b = ((z4 << 3) ^ z4) >> 12;
        z4 = ((z4 & 4294967168U) << 13) ^ b;
        return (z1 ^ z2 ^ z3 ^ z4);
    }
    void srand_(int n, int v)
    {
        scanf("%u%u%u%u", &z1, &z2, &z3, &z4);
        for(int i = 1; i <= n; i++) a[i] = rand_() % v + 1;
    }
}
```

第一行会输入两个数 $n,v$，表示观测天数和 Left 猜测的上限（即 $v=\max\limits_{i=1}^n a_i$）。

接下来你需要调用 `Gen::srand_(n,v)`。

第二行会输入四个在 `unsigned` 存储范围内的数，表示随机种子。输入后，生成器将帮助你生成好 Left 猜测的降水量序列 $\{a_n\}$，下标从 $1$ 开始地存储在了数组 `a[]` 中。

直接复制 PDF 中的生成器会携带不必要的行号和页眉页脚。我们在下发文件中提供了样例程序，你可以在那里复制生成器到自己的代码中，也可以更详细地了解生成器的用法。

{{ s('output format') }}

{{ self.output_file() }}

输出一个数，表示满足条件的不同实际降水量序列 $\{x_n\}$ 数量，对 $10^9+7$ 取模。

{{ s('sample', 1) }}

{{ self.sample_text() }}

{{ self.title_sample_description() }}

生成的序列 $\{a_n\}$ 为 $[2,1,3,2,3]$。

所有六种可能的**符合 Left 预期的复杂的**实际降水量序列 $\{x_n\}$ 如下：

- $[2,1,2,1,2]$
- $[2,1,2,1,3]$
- $[2,1,3,1,2]$
- $[2,1,3,1,3]$
- $[2,1,3,2,1]$
- $[2,1,3,2,3]$

对于其他的一些序列：

- 序列 $[1,2,3,2,3]$ 等不满足条件，因为不符合 Left 预期（第二天）。
- 序列 $[1,1,3,2,3]$ 等不满足条件，因为不是复杂的（第一天和第二天的降水量相同）。
- 序列 $[2,1,3,3,3]$ 等不满足条件，因为既不符合 Left 预期，也不复杂。

可以证明不存在更多的**符合 Left 预期的复杂的**实际降水量序列。

{{ s('sample', 2) }}

{{ self.sample_file() }}

这组样例满足测试点 $2$ 的限制。

{{ s('sample', 3) }}

{{ self.sample_file() }}

这组样例满足测试点 $4$ 的限制。

{{ s('sample', 4) }}

{{ self.sample_file() }}

这组样例满足测试点 $5,7$ 的限制。

{{ s('sample', 5) }}

{{ self.sample_file() }}

这组样例满足测试点 $6,8$ 的限制。

{{ s('sample', 6) }}

{{ self.sample_file() }}

这组样例满足测试点 $11$ 的限制。

{{ s('sample', 7) }}

{{ self.sample_file() }}

这组样例满足测试点 $12$ 的限制。

{{ s('sample', 8) }}

{{ self.sample_file() }}

这组样例满足测试点 $17,19$ 的限制。

{{ s('sample', 9) }}

{{ self.sample_file() }}

这组样例满足测试点 $18,20$ 的限制。

{{ s('sample', 10) }}

{{ self.sample_file() }}

这组样例满足测试点 $23,25$ 的限制。

{{ s('部分分设置') }}

对于 $100\%$ 的数据，$1\le n\le 2\times 10^7$，$1\le v\le 10^9$。

{{tbl('data')}}

特别地，对于所有偶数测试点，均有 $v\le n$。

{{ s('hint') }}

**请注意常数因子对程序效率的影响**。

{{ s('后记') }}

Left，爱上湖中倒影，害怕触碰到你。