{{ s('background') }}

{{ img('background.png', size = 0.4, align = 'middle', inline = False, caption='“太多烦心事只有选择伴奏我愿意斟酌”') }}

车站通常是随着时光开始后退。

{{ s('description') }}

**这是一道交互题**。

一切都很短暂，只有音乐是永远无法消逝的。

Simons 在离开前留下了 $n$ 个乐章，这些乐章按照 $1$ 到 $n$ 的顺序排列在保险箱里，其中第 $i$ 个乐章的出彩度为 $a_i$。

离别总是太过突然，所以我们无法解锁 Simons 的保险箱。不过我们仍然可以有机会窥见这些乐章的美好。具体来说，你可以向保险箱获取区间 $[l,r]$ 中的乐章的出彩度的**可空**最大子段和。

形式化地，你可以向保险箱询问一个区间 $[l,r]$，获取 $\max(0,\max\limits_{i=l}^{r}\max\limits_{j=i}^{r}\sum\limits_{i\le k\le j}a_k)$。

由于保险箱在 $2n$ 次询问后就会自焚，你的任务是在 $2n$ 次询问以内确定一个长度为 $n$ 的乐章出彩度序列 $\{b_n\}$，满足：

- $\{b_n\}$ 中每个区间的**可空**最大子段和都和实际的 $\{a_n\}$ 中相等。形式化地，即对于所有区间 $[l,r]$，都有 $\max(0,\max\limits_{i=l}^{r}\max\limits_{j=i}^{r}\sum\limits_{i\le k\le j}a_k)=\max(0,\max\limits_{i=l}^{r}\max\limits_{j=i}^{r}\sum\limits_{i\le k\le j}b_k)$。

如果有多种 $\{b_n\}$，返回任意一种均可。

当然，保险箱中的乐章的出彩度不会因你的询问而改变。

Simons 一共有 $500$ 个保险箱，每 $20$ 个一组。在 z!mo 和 Left 等人对电路的一通捣鼓后，现在即便你无法在 $2n$ 次询问内确定也可以打开部分保险箱了。具体请阅读【部分分设置】。 

{{ s('交互方式') }}

你不需要也不应该直接读入或输出任何数据。你不需要也不应该实现主函数。

你需要实现一个函数 `int[] rhythm(int n, int q, int c)`，$n$ 为保险箱中的乐章数量，$q$ 为询问次数上限，$c$ 为测试点编号。返回值为一个长度为 $n$ 的数组，下标从 $0$ 开始，第 $i$ 项表示 $b_{i+1}$。保证该函数在每个测试点中被调用恰好 $20$ 次。

你的实现可以调用函数 `long long rewind(int l,int r)`，它会返回 $\{a_n\}$ 的区间 $[l,r]$ 的**可空**最大子段和。每次 `rhythm()` 中你最多只能调用 `rewind()` $q$ 次。

若你的调用出现 $l<1$ 或 $r>n$ 或 $r>l$ 的任一情况，或是调用次数超出了 $q$ 次，你将获得 $-10^{18}$ 的返回值，该测试点将被判定为 Wrong Answer，此时你也应该立即任意返回答案以终止。若在出现此情况后继续运行，获得的结果将无法预测。

此外，实际的出彩度序列 $\{a_n\}$ 不会随着你的询问而发生改变。换而言之，交互库**不是自适应**的。具体请阅读【测试细节】。

{{ s('测试细节') }}

**提交时你的程序应当以 `#include "rhythm.h"` 的形式附带 `rhythm.h` 头文件**。

题目保证在各函数规定的调用次数限制下，交互库运行的时间不超过 $2$ 秒，交互库使用的内存固定且大小不超过 35MiB。本地测试时请注意交互库对你的程序效率表现产生的影响。

我们在下发文件中下发了交互库 `grader.cpp`，本题需要的头文件 `rhythm.h`，编译程序 `compile_cpp.sh/.bat` 和示例代码 `sample.cpp`。你可以在示例代码的基础上编写程序。

下面介绍本地测试方法。

##### 对于 Windows 系统

- 将下发文件中的程序全部移动到你的工作文件夹，并将你的代码命名为 `rhythm.cpp`，然后运行 `compile_cpp.bat`。
- 若通过编译，此时你的工作文件夹下会出现 `rhythm.exe`。运行后通过**标准输入**输入样例输入。

##### 对于 Linux 系统

- 将你的栈空间手动调至 512MiB。
- 将下发文件中的程序全部移动到你的工作文件夹，并将你的代码命名为 `rhythm.cpp`，然后运行 `compile_cpp.sh`。
- 若通过编译，此时你的工作文件夹下会出现 `rhythm`。运行后通过**标准输入**输入样例输入。

##### 交互库的响应

- 正常情况下，每组数据交互库都会向屏幕上打印 `OK: Simons did it`，表示你确定的出彩度序列 $\{b_n\}$ 满足题目条件，且询问次数合法。
- 若出现 `Wrong Answer: Invalid call` 意味着你的程序进行了不合法调用，可能是你的 $l,r$ 超出范围，也可能是超出询问次数限制。
- 若出现 `Wrong Answer: Unlike Simons` 意味着你确定的出彩度序列 $\{b_n\}$ 不满足题目条件。

当然，你也可以通过修改交互库源代码的方式将交互库改为文件输入输出，方便对比样例。

特别注意：

- 本题首先受到和传统题一样的限制。例如编译错误、超出空间限制、超出时间限制等仍然会获得 $0$ 分。
- 修改下发文件对最终测试是**无效操作**。最终测试只会收取你编写的 `rhythm.cpp`。
- 你不应通过非法方式获取交互库的内部信息，如试图直接读取序列 $\{a_n\}$ 的值，操作文件指针和内存池，或直接与标准输入、输出流进行交互。**此类行为将被视为作弊。**
- 最终测试的交互库与下发交互库有所不同，**你的解法不应该依赖交互库实现**。

{{ s('input format') }}

{{ self.input_file() }}

你不需要直接从输入文件中读入任何数据。这里描述的是交互库输入的数据格式。

第一行一个整数 $c,n,q$，分别表示测试点编号、该测试点中所有保险箱乐章的数量、该测试点中所有保险箱的询问次数的上限。对于样例均有 $c=0$。

接下来 $20$ 行每行一个长度为 $n$ 的序列 $\{a_n\}$，描述一个保险箱中的乐章的出彩度。

{{ s('output format') }}

{{ self.output_file() }}

你不需要直接向输出文件中输出任何数据。这里描述的是交互库输出的数据格式。

$20$ 行 `OK: Simons did it`。特别地，如果你的程序有误，将输出其他的信息。具体请阅读【测试细节】。

{{ s('交互示例') }}

假设我们有一个 $c=0,n=5,q=15$，实际乐章出彩度序列为 $[2,-1,3,-4,5]$ 的保险箱。下面是一种可能的交互过程：

{{tbl('explain')}}

在这个例子中，选手程序使用 $4$ 次合法询问返回了一种正确答案。请注意这可能并非一个合理的程序交互过程。

{{ s('sample', 1) }}

{{ self.sample_file() }}

这组样例满足测试点 $1\sim 3$ 的数据范围。

{{ s('sample', 2) }}

{{ self.sample_file() }}

这组样例满足测试点 $4$ 的数据范围。

{{ s('sample', 3) }}

{{ self.sample_file() }}

这组样例满足测试点 $7$ 的数据范围。

{{ s('sample', 4) }}

{{ self.sample_file() }}

这组样例满足测试点 $9$ 的数据范围。

{{ s('sample', 6) }}

{{ self.sample_file() }}

这组样例满足测试点 $12$ 的数据范围。

{{ s('sample', 7) }}

{{ self.sample_file() }}

这组样例满足测试点 $14$ 的数据范围。

{{ s('sample', 8) }}

{{ self.sample_file() }}

这组样例满足测试点 $17,18$ 的数据范围。

{{ s('部分分设置') }}

对于 $100\%$ 的数据，$1\le n\le 2000$，$-10^9\le a_i\le 10^9$，$q\ge 2n$。保证每组数据中你的 `rhythm()` 函数会被调用恰好 $20$ 次。

{{tbl('data')}}

特殊性质 A：$\{|a_n|\}$ 互不相同。

特殊性质 B：$\{|a_n|\}$ 单调递增。

特殊性质 C：$\forall i\in[1,n),a_ia_{i+1}<0$。

特殊性质 D：$\forall i\in[1,n),a_ia_{i+1}>0$。

特殊性质 E：不存在 $a_i=0$。

{{s('后记')}}

Simons，用爱解释我的存在。